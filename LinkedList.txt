Linked List Data Structure

Problem Solutions:

1. Finding the Middle Node (Using the Tortoise and Hare Algorithm)
Explanation: Having two pointers one going twice as fast as the other pointer. Once the "hare" pointer reaches the end, the "tortoise" pointer will reach the middle node.

public Node findMiddleNode() {
        Node tortoise = head;
        Node hare = head;
        while (hare != null && hare.next != null) {
            hare = hare.next.next;
            tortoise = tortoise.next;
            

    }
            return tortoise;
}

2. Implement a method called hasLoop that checks whether the list contains a loop or not.
If the list contains a loop, the method should return true; otherwise, it should return false.

Explanation: Again use the Tortoise and Hare Algorithm, if there is a cycle, there should be a point where tortoise and hare are eventually equal.

 public boolean hasLoop () {
        Node tortoise = head;
        Node hare = head;
        
        while (hare != null && hare.next != null) {
            hare = hare.next.next;
            tortoise = tortoise.next;
            if (hare == tortoise) {
                return true;
            }
        }
        return false;
    }

3. Implement a method called findKthFromEnd that returns the k-th node from the end of the list.
If the list has fewer than k nodes, the method should return null.

Explanation: Use two pointers starting at head. Loop through a fast pointer kth times so it's ahead of the 2nd pointer. Once the fast pointer reaches the end of the Linked List, the Slow pointer will reach the kth node from the end of the list!

    public Node findKthFromEnd(int k) {
        Node hare = head;
        Node tortoise = head;
        
        for (int i = 0; i < k; i++) {
            if (hare == null) {
                return null;
            }
            hare = hare.next;
        }
        while (hare != null) {
            hare = hare.next;
            tortoise = tortoise.next;
        }
        return tortoise;
        
    }
